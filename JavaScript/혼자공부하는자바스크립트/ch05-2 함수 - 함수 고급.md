# 05-2 함수 고급

# 0 시작하기전에
다른 프로그래밍 언어는 함수를 지정된 위치에서 만들어야 하지만, 자바스크립트는 `'함수도 하나의 자료'`라는 개념을 가지고 있어서 `중간에` 만들 수 있다. 이는 2010년 전후에 등장한 `비동기 프로그래밍`을 이끌었다. 자바스크립트의 `익명 함수`는 문법적 가치를 크게 인정받아 다른 프로그래밍 언어로 전파되었다. 람다 또는 익명함수라는 이름으로 기본 문법에 포함되었다.(익명함수가 중간에 만드는 만들수있는함수인건가?)  

자바스크립트는 느리고, 변수와 함수 등이 너무 유연해서 제대로 활용될 수 없으므로 과거 사람들은 쓸모 없어 곧 사라질 언어로 자바스크립트를 뽑았었다.  
자바스크립트는 크롬이 등장한 이후 급속도로 빨라졌고, 비동기 프로그래밍 등장으로 문법적 가치를 인정받아 지금까지 사용되고 있다는 건 매우 아이러니하다. 

![image](https://user-images.githubusercontent.com/68311318/121027907-4ccd6e80-c7e2-11eb-935b-fb2ae5b5be4e.png)

# 1 콜백 함수
자바스크립트는 함수도 하나의 자료형이므로 매개변수로 전달할 수 있다. 이렇게 매개변수로 전달하는 함수를 콜백 함수라고 한다. 다른 언어에서 찾아보기 힘든 개념이다. 

```javascript
      function callThreeTimes (callback) {
        for (let i = 0; i < 3; i++) {
          callback(i)
        }
      }

      function print (i) {
        console.log(`${i}번째 함수 호출`)
      }

      callThreeTimes(print)
```

위를 익명함수를 사용하면 다음과 같이 바꿀 수 있다.

```javascript
function callThreeTimes (callback) {
  for (let i = 0; i < 3; i++) {
    callback(i)
  }
}

callThreeTimes(function (i) {
  console.log(`${i}번째 함수 호출`)
})
```

자바스크립트가 기본적으로 제공하는 함수 중에도 콜백 함수를 활용하는 함수가 많다

## 1-1 콜백 함수를 활용하는 함수 : forEach()
콜백함수를 활용하는 가장 기본적인 함수는 forEach() 메소드이다. forEach() 메소드는 배열이 갖고 있는 함수(메소드)로써 `단순하게 배열 내부의 요소를 사용해서 콜백 함수를 호출해준다.`  

배열이 갖고 있는 메소드 중에서 콜백 함수를 활용하는 메소드는 다음과 같은 형태의 콜백 함수를 사용한다.  
```
function (value, index, array) { }
```

```javascript
      const numbers = [273, 52, 103, 32, 57]

      numbers.forEach(function (value, index) {
        console.log(`${index}번째 요소 : ${value}`)
      })
```

## 1-2 콜백 함수를 활용하는 함수 : map()
map() 메소드는 `콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만드는 함수`이다.


```javascript
     let numbers = [273, 52, 103, 32, 57]

      numbers = numbers.map(function (value) {
        return value * value
      })

      numbers.forEach(console.log)
```
## 1-3 콜백 함수를 활용하는 함수 : filter()
filter() 메소드도 배열이 갖고 있는 함수이다. filter() 메소드는 `콜백 함수에서 리턴하는 값이 true인 것들만 모아서 새로운 배열을 만드는 함수`이다.

```javascript
      const numbers = [0, 1, 2, 3, 4, 5]
      const evenNumbers = numbers.filter(function (value) {
        return value % 2 === 0
      })

      console.log(`원래 배열: ${numbers}`)
      console.log(`짝수만 추출: ${evenNumbers}`)
```

# 2 화살표 함수
앞에서 살펴본 map(), filter() 함수처럼 단순한 형태의 콜백 함수를 쉽게 입력하고자 화살표 함수라는 함수 생성 방법이 있다. 화살표 함수는 function 키워드 대신 화살표(=>)를 사용하며, 다음과 같은 형태로 생성하는 간단한 함수이다.  
```
(매개변수) => {

} 불 표현식 || 불 표현식이 거짓일 때 실행할 문장
```

화살표 함수는 다음과 같이 간편하게 사용할 수 있다.
```
(매개변수) => 리턴값
```

내부에서 this 키워드가 지칭하는 대상이 다르다는 등의 미세한 차이가 있다. 아직 this 키워드를 배우지 않았으므로 현 단계에서는 `'콜백 함수에 활용하는 function() {}의 간단한 사용 형태'`라고만 기억하자. 차이에 대해서는 chap 06에서.  

예를 들어 이전의 map() 함수의 콜백 함수로 화살표 함수를 넣는다면 다음과 같이 코드를 작성한다.
```
> const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
undefined

> array.map((value) => value * value)
(10) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

```javascript
      let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

      numbers
        .filter((value) => value % 2 === 0)
        .map((value) => value * value)
        .forEach((value) => {
          console.log(value)
        })

```

filter()는 배열을 리턴하므로 map() 메소드를 적용할 수 있고 map() 메소드도 배열을 리턴하므로 forEach()를 적용할 수 있다. 이렇게 어떤 메소드가 리턴하는 값을 기반으로 해서 함수를 줄줄이 사용하는 것을 메소드 체이닝이라고 부른다.

# 3 타이머 함수
자바스크립트에는 다음과 같이 특정 시간마다 또는 특정 시간 이후에 `콜백 함수`를 호출할 수 있는 타이머 함수들이 있다. 이 함수를 사용하면 시간과 관련된 처리를 할 수 있다.
```
setTimeout(함수, 시간) : 특정 시간 후에 함수를 한 번 호출한다
setInterval(함수, 시간) : 특정 시간마다 함수를 호출한다
```

```javascript
      setTimeout(() => {
        console.log('1초 후에 실행됩니다')
      }, 1000)

      let count = 0
      setInterval(() => {
        console.log(`1초마다 실행됩니다(${count}번째)`)
        count++
      }, 1000)
```

타이머를 종료하고 싶을 때는 clearTimeout() 함수와 clearInterval() 함수를 사용한다.  
```
clearTimeout(타이머_ID) : setTimeout() 함수로 설정한 타이머를 제거한다
clearInterval(타이머_ID) : setInterval() 함수로 설정한 타이머를 제거한다
```
타이머_ID라는 것은 setTimeout() 함수와 setInterval() 함수를 호출할 때 리턴값으로 나오는 숫자이다.  

```javascript
      let id
      let count = 0
      id = setInterval(() => {
        console.log(`1초마다 실행된다(${count}번째)`)
        count++
      }, 1000)

      setTimeout(() => {
        console.log('타이머를 종료합니다.')
        clearInterval(id)
      }, 5000)
```

# 좀더 알아보기 
## 1 즉시 호출 함수
여러 자바스크립트 코드를 보면 다음과 같이 익명 함수를 생성하고 곧바로 즉시 호출하는 패턴을 많이 볼 수 있다. 왜 이런코드를 사용하는 걸까.  
```
(function () { })()
```

일반적으로 자바스크립트는 HTML 페이지 내부에서 사용할 때 script 태그를 여러개 사용하고 코드를 입력한다. 
```html
    <script>
      let pi = 3.14
      console.log(`파이 값은 ${pi}입니다.`)
    </script>    

    <script>
      let pi = 3.141592
      console.log(`파이 값은 ${pi} 입니다.`)
    </script>
```

이렇게 코드가 여러 곳에서 사용되면 변수 이름이 충돌할 가능성이 높다. 위의 코드는 오류가 난다.  
변수가 존재하는 범위를 어려운 말로 스코프라고 부르는데 이 스코프는 같은 단계에 있을 경우 무조건 충돌이 일어난다. 자바스크립트에서 이러한 스코프 단계를 변경하는 방법은 1. 중괄호를 사용해서 `블록`을 만들거나, 2. 함수를 생성해서 `블록`을 만드는 방법이다.  

```javascript
      let pi = 3.14
      console.log(`파이 값은 ${pi}입니다`)

      {
        let pi = 3.141592
        console.log(`파이 값은 ${pi}입니다.`)
      }
      console.log(`파이 값은 ${pi}입니다.`)

      function sample() {
        let pi = 3.141592
        console.log(`파이 값은 ${pi}입니다`)
      }

      sample()
      console.log(`파이 값은 ${pi}입니다.`)
```

이렇게 블록 내부에서 같은 이름으로 변수를 선언하면 변수가 외부 변수와 충돌하지 않고 외부 변수를 가린다. 내부 블록에서는 내부 블록에서 선언한 변수만 볼 수 있다. 이렇게 블록이 다른 경우 내부 변수가 외부 변수를 가리는 현상을 조금 어려운 말로 섀도잉이라고 부른다.

## 2 즉시 호출 함수 문제 해결하기
1 블록을 사용하는 방법과 2 함수 블록을 사용해 변수 충돌을 막는 방법 모두 최신 자바스크립트를 지원하는 웹브라우저에서는 사용할 수 있다. 하지만 구 버전의 자바스크립트에서 변수를 선언할 때 사용하던 var 키워드는 `함수 블록을 사용하는 경우에만 충돌을 막을 수 있다.`  

지금도 구버전의 자바스크립트를 지원하는 웹 브라우저(인터넷 익스플로러)에 대응해야 하는 경우가 많고, Babel 등 최신 버전의 자바스크립트를 구 버전의 자바 스크립트로 변경해주는 트랜스파일러(465쪽)도 단순한 블록으로 함수 충돌을 막는 코드는 제대로 변환해주지 못한다.  

그래서 많은 개발자들이 함수 블록을 사용해 이런 문제를 해결한다. `충돌 문제를 해결하기 위해 사용하는 것이므로` 함수를 만들자마자 즉시 호출할 수 있도록 다음과 같이 작성한다.  

```javascript
    <script>
      let pi = 3.14
      console.log(`파이 값은 ${pi}입니다`)
    </script>

    <script>
      (function () {
        let pi = 3.141592
        console.log(`파이 값은 ${pi}입니다.`)
      }) ()
    </script>
```

## 3 엄격 모드
```javascript
'use strict'
data = 10
console.log(data)
```
오류가 난다  
자바스크립트는 오류를 어느정도 무시하고 넘어가는 것들이 있다. 그래서 편하게 코딩할 수 있지만 실수로 이어지기도 한다. 일반적으로 엄격 모드를 사용하는 것이 좋다. 엄격 모드에서 발생하는 오류에 대해서는 모질라 엄격 모드 문서()를 참고하라. https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode  
엄격하다는 기준은 시간에 따라 변한다. 자바스크립트의 엄격 모드도 시간에 따라 기준이 계속 변하므로 주의하라.  

즉시 호출 함수를 만들고, 이 블록의 가장 위쪽에서 엄격 모드를 적용하는 경우가 많다. 이렇게 하면 `해당 블록 내부에만` 엄격 모드가 적용된다. 엄격 모드의 일반적인 사용패턴은 다음과 같다.
```javascript
(function () {
  'use strict'
  문장
  문장
}) ()
```

## 4 익명 함수와 선언적 함수의 차이
while 반복문과 for 반복문은 2가지 모두 많이 사용되지만, 사용하는 상황이 조금씩 다르다. while 반복문은 조건을 중심으로 반복할 때, for 반복문은 횟수를 중심으로 또는 배열을 중심으로 반복할 때 사용한다.  

그런데 익명함수와 선언적 함수는 사용하는 상황이 비슷하다. 기본적으로는 혼자 개발할 때는 자신이 편하다고 생각하는 것을 사용하고, 다른 사람들과 함께 개발할 때는 모두가 편하다고 생각하는 것을 사용하면 된다. 다만 최근의 많은 개발자가 안전 등의 이유로 익명함수를 선호하는 편이다. 왜 익명함수가 더 안전하다고 하는지, 어떤 차이가 있기에 그러는지 간단하게 알아보자  

### 4-1 익명함수의 사용
익명 함수는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성된다. 따라서 다음과 같은 코드가 있다면 위에서 아래로 차례대로 코드가 실행되면서 익명 함수라는 변수에 '2번째 익명 함수입니다'를 호출하는 함수가 할당된다.  

```javascript
      let 익명함수

      익명함수 = function () {
        console.log('1번째 익명 함수입니다')
      }

      익명함수 = function() {
        console.log('2번째 익명 함수입니다')
      }

      익명함수()
```

### 4-2 선언적 함수와 익명 함수의 조합
2가지 상황이 조합된 경우에는 어떻게 될까. 선언적 함수는 먼저 생성되고, 이후에 순차적인 코드 진행을 시작하면서 익명 함수를 생성한다. 따라서 다음과 같은 코드를 작성하면 코드의 순서와 관계없이 "익명 함수입니다"라는 글자를 출력한다.  

```javascript
함수 = function () {
  console.log('익명 함수입니다')
}

function 함수 () {
  console.log('선언적 함수입니다.')
}

함수()
```
익명 함수는 우리가 코드를 읽을 때와 같은 순서로 함수가 선언되지만 선언적 함수는 우리가 코드를 읽는 순서와 다른 순서로 함수가 선언된다. 함수를 같은 이름으로 덮어쓰는 것은 굉장히 위험한 일이다. 그래서 안전하게 사용할 수 있도록 익명 함수를 더 선호하는 것이다. 

### 4-3 블록이 다른 경우에 선언적 함수의 사용
선언적 함수는 어떤 코드 블록(`script 태그` 또는 `함수` 등으로 구분되는 공간)을 읽어들일 때 먼저 생성된다. 다음 코드의 실행 결과를 예측해보자.

```html
    <script> // 블록 A
      선언적함수()

      function 선언적함수() {
        console.log('1번째 선언적 함수입니다.')
      }
    </script>

    <script> // 블록 B
      function 선언적함수() {
        console.log('2번째 선언적 함수이다.')
      }
    </script>

    <script>
      선언적함수()
    </script>
```

실행결과는  
1번째 선언적 함수입니다  
2번째 선언적 함수입니다  
이다.  
이처럼 블록이 나뉘어진 경우에는 선언적 함수의 실행 흐름을 예측하는 것이 훨신 힘들어진다. 다른 프로그래밍 언어들은 일반적으로 선언적 함수 형태로 함수를 많이 사용하지만, 자바스크립트는 이처럼 블록이 예상하지 못하게 나뉘는 문제 등이 발생할 수 있어 안전을 위해 익명 함수를 더 많이 사용하는 편이다.  

과거 자바스크립트는 var이라는 키워드를 사용해서 변수를 선언했다. var 키워드는 이전 코드처럼 덮어쓰는 문제가 발생한다. 하지만 현대의 자바스크립트는 let키워드와 const키워드를 사용해서 변수와 상수를 선언한다. 그리고 이러한 키워드들은 위험을 원천적으로 차단하기 위해서 오류를 발생시킨다.  

```javascript
      let 함수 = function () {
        console.log('익명 함수입니다')
      }

      function 함수 () {
        console.log('선언적 함수입니다')
      }

      함수()
      // Uncaught SyntaxError: Identifier '함수' has already been declared
      // 4-2에서는 let을 안붙였는데 에러가 안났다. 아마 안붙이면 자동으로 var로 선언되는것같다.
```
따라서 한가지로 통일해서 사용하는 것이 오류의 위험을 줄일 수 있고, 통일한다면 익명 함수로 통일해서 사용하는 것이 안전을 위해서 더 편한 선택이다.  

# 마무리
콜백함수란 매개변수로 전달하는 함수를 의미한다  
화살표 함수란 익명 함수를 간단하게 사용하기 위한 목적으로 만들어진 함수 생성 문법이다. () => {} 형태로 함수를 만들고, 리턴값만을 가지는 함수라면 () => 값 형태로 사용할 수 있다.  
즉시 호출 함수란 변수의 이름 충돌을 막기 위해서 코드를 안전하게 사용하는 방법이다.  
자바스크립트의 문법오류를 더 발생시키는 엄격 모드는 실수를 줄일 수 있는 방법이다. 'use strict'라는 문자열을 블록 가장 위쪽에 배치해서 사용할 수 있다.  

# 확인문제
## 1 filter 함수의 콜백 함수 부분을 채워서 1. 홀수만 추출, 2. 100 이하의 수만 추출, 3. 5로 나눈 나머지가 0인수만 추출해라
```javascript
      let numbers = [275, 25, 75, 52, 103, 32, 57, 24, 76]

      numbers = numbers.filter((value) => value % 2 !== 0)
                       .filter((value) => value <= 100)
                       .filter((value) => value % 5 === 0) 
      console.log(numbers)
```

## 2 forEach를 사용하라
```javascript
const array = ['사과', '배', '귤', '바나나']

console.log('# for in 반복문')
for (const i in array) {
  console.log(i)
}

console.log('# for of 반복문')
for (const i of array) {
  console.log(i)
}
```
forEach를 사용해라
```javascript
const array = ['사과', '배', '귤', '바나나']

console.log('# for in 반복문')

array.forEach((item, i) => {console.log(i)})

console.log('# for of 반복문')
array.forEach((item) => {console.log(item)})
```
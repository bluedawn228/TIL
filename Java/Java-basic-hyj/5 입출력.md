# 입출력

**입출력의 단위는 크게 두가지로 나뉜다 패킷이냐 스트림이냐**  
패킷은 주고받는게 명확하다 나 보냈어 나 받았어까지 응답을 보내야한다 근데 스트림은 아니다. 

**왜 nextint()를 쓰지 않고 nextLine()을 썻나**  
왜냐면 만약 10와 엔터를 입력하면 nextint()는 10만 읽는다. 그래서 '스트림이 모든 데이터를 갖고왓지만(10) 쓰레기값(엔터)이 남아잇을 수도 있다'는 인식이 있어야한다. 그래야 이상현상이 있을때 좀더 원인을 찾기 쉽다.   

**바이트 스트림의 int read()는 왜 리턴타입이 int인가**  
```java
public abstract class InputStream {
    ...
    // 입력스트림으로부터 1byte를 읽어서 반환한다. 읽을 수 없으면 -1을 반환한다
    abstract int read();

    // 입력스트림으로부터 len개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다
    int read(byte[] b, int off, int len) {
        ...
        for(int i = 0; i < off + len; i++) {
            // read()를 호출해서 데이터를 읽어서 배열을 채운다
            b[i] = (byte)read();
        }
    }
    ...
    // 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다
    int read(byte[] b) {
        return read(b, 0, b.length);
    }
    ...
}
```
심지어 for문안에보면 byte로 캐스팅하는 것을 볼수있다. 왜 도대체 리턴타입이 int인가. 1byte씩 읽는데 최적화를 위해서 변수를 4byte를 준것뿐이다. 무슨뜻이냐면,0 32bit시스템은 버스가 32개라는 의미이다. 버스가 32개라는 뜻은 cpu와 램사이에 연결된 선을 버스라고 한다. 그게 32개가 있다는 거다. 결국 얘네들은 신호를 통해서 읽고 쓴다. 선이 32개가 있으면 어떤건 신호를 주고 어떤건 신호를 안주고하는 방식으로 읽고 쓴다. cpu는 동시에 32개의 선에 한꺼번에 신호를 보낸다. 그리고 신호를 받는다. 내가 8개만 신호를 보내고 싶다? 안된다. 8개만 보내고 싶어도 앞에 나머지 애들은 전부 0으로 채워서 32비트로 보내야한다. 그래서 최적화를 위해서는 int로 해야한다. 우리는 64비트 컴퓨터를 쓰고 있지만 아직 32비트인게 많기 때문이다. 그래서 리턴타입은 int지만 한바이트씩 읽어온다.  

**'A'와 "A"**  
'A'는 2byte이다. "A"는 4byte이다. "A"는 A뒤에 null이붙어있다. A가 2byte고 null이 2byte 그래서 총 4byte이다. 이렇게 약속을 해서 시작위치에서 null까지를 읽어오는 것이다. 왜냐면 문자열은 길이가 천차만별이기 때문에 이런 약속을 하는 것이다. 자바만 그런게 아니고 다른 언어도 다 그렇다. 즉, 문자열을 저장할때는 약속이 있다. 뒤에 null을 넣어야한다. 큰따옴표가 그 의미를 포함하고 있다. String st = "A"에서 String은 null까지를 갖고온다는 의미를 포함하고 있는 것이다. 



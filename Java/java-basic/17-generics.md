# 제네릭
제네릭 문법이 탄생한 것은 아주 자연스러운 흐름이다. 클래스는 다른 클래스를 의존한다. 그런데 그 의존하는 객체의 타입을 제한하고 싶다. 그래서 객체의 타입을 제한하는 문법(제네릭)이 탄생한것이다.    

제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 `컴파일` 시의 타입 체크를 해주는 기능이다. 객체의 타입을 `컴파일` 시에 체크하기 때문에 1. 타입 안정성을 높이고 2.형변환의 번거로움이 줄어든다.  

제네릭 문법의 목적은 `코드 안정성`을 추구하는 것이다. 원하는 타입이 아닌 다른 타입의 값을 지정하는 오류(타입 오류)를 `줄이기 위해` 만든 문법이다. 제네릭 문법의 대상은 컴파일러다. 즉 컴파일 단계에서 최대한으로 타입 오류를 잡아내는 것이 목적이다.  

**제네릭(generic)** 문법을 이용하면,  
1. 같은 일을 하는 클래스 정의할 때 타입 별로 중복해서 정의할 필요가 없기 때문에 `코드의 재사용성`을 높인다.(이건 다형성에도 똑같이 해당되는 말이다. 다형성을 이용해서도 클래스를 타입별로 중복해서 정의할 필요가 없고, 제네릭을 사용해서도 타입별로 중복해서 정의할 필요가 없다. 그러나 다형성에는 약간의 한계가 있다. 그래서 제네릭이 등장했다)
2. 지정된 타입의 객체만 다루도록 제한할 수 있어 `코드의 안정성`을 높인다.
    - 사용할 객체의 타입을 지정한 후 잘못된 타입의 객체를 사용할 때 `컴파일 오류`가 발생한다.
    - 컴파일 할 때 타입 검사를 진행하기 때문에 `빠른 시점에` 타입 안정성을 어긴 오류를 찾아 낼 수 있다.
    - 가능한 실행할 때 발생된 오류 보다는 `컴파일 할 때 발생된 오류를 잡는 것이 더 낫다.`

## 다형성과 제네릭의 등장 배경
다형성이라는 개념이 등장하기 전에는 `같은 일을 하는 클래스임에도` 다루는 객체 타입이 다르다는 이유로 반복적으로 정의해야 했다. 예를 들면 ArrayList에 담을 타입에 따라 ArrayList클래스를 여러개 만들어야한다. (StringArrayList, MemberArrayList, IntegerArrayList 등)
주의 : 실제 ArrayList<E> 클래스에는 Object[]가 있다. E[]가 아니다. 제네릭 배열은 생성할수도 없다.  

그래서 다형성이라는 개념이 등장한다. 다형성을 이용하면(Object) 다형성을 이용하면 StringArrayList, MemberArrayList, IntegerArrayList이 다 필요없어지고 ArrayList하나만 있으면 된다.  
그러나 이 다형성만으로도 한계가 있다. ArrayList에서 값을 꺼낼때마다 원래의 타입으로 형변환해야하는 일이 굉장히 많고, ArrayList가 다루는 객체를 특정 타입의 객체로 제한할 수 없다(Object를 다루고 있으므로 Object의 자손들은 전부 ArrayList의 메서드의 매개변수로 들어갈수있다).  
이러한 한계를 극복하고자 제네릭이라는 문법이 등장한 것이다. 제네릭을 사용하면 형변환의 번거로움이 없어지고, 특정 타입 `전용` 클래스로 만들 수 있다. 즉, 제네릭 문법을 사용하면 Object타입을 사용하는 것보다 보다 편리하다. 또한 각 타입별로 클래스를 따로 정의한듯한 효과가 있다.(제네릭을 사용하지 않고 다형성만 이용했다면 앞서 살펴본것과 같이 이러한 효과는 얻을 수 없다. 그러나 제네릭을 사용하면 마치 StringArrayList, MemberArrayList, IntegerArrayList 등을 정의한 효과가 있다)  
제네릭은 `클래스`에서 다룰 객체의 타입을 `파라미터`로 받는다(타입 파라미터).  
# 24. 인터페이스를 활용한 객체 사용 규칙 정의
> 인터페이스는 객체의 사용 규칙을 정의하는 문법이다. 목적은 유지보수이다.  

인터페이스란 객체 사용 규칙을 정의하는 문법이다. 인터페이스를 마주치면 누가 호출하고 누가 호출 당하는지 빨리 파악해야 한다. 그리고 우리가 호출하는 프로그램을 짜는 입장인지, 호출 당하는 프로그램을 짜는 입장인지 빨리 파악해야 한다.  
나중에 배울 Servlet이 그 예이다. Servlet은 호출 규칙이고, 개발자는 호출 당하는 프로그램을 짜면 된다. 그러면 Tomcat Server와 같은 웹서버가 이를 호출하게 된다.  
![image](https://user-images.githubusercontent.com/68311318/123500252-b3bea480-d677-11eb-9c6c-b9c1ca09ea5a.png)

23에서 AbstractList를 정의하여 추상클래스를 만들어보았다.  
그런데 MemberHandelr는 Member의 이메일을 중복 허용하고 싶지 않아서 ArrayList보단 HashSet을 사용하고 싶다. 그래서 우리가 AbstractList를 정의하여 유연성을 늘렸던 것처럼 유연성을 더 늘려보자. 추상클래스를 또 만들까 싶지만(만들어도 된다) 인터페이스가 추상클래스보다 더 유연하다. 상속관계를 다형적 변수로 이용하면 그 자손들만 가리킬수 있다. 그렇지만 인터페이스를 다형적 변수로 이용하면, 누구든지 그 인터페이스를 구현하기만 한 애들을 가리킬수 있기 때문이다(누가 누구를 상속하든지 알바아님). 실무에 가면 파라미터에 인터페이스가 많은 이유가 이것이다.  
![image](https://user-images.githubusercontent.com/68311318/123498925-de0b6480-d66d-11eb-9897-8ea72888f96a.png)  


**인터페이스** 는 

- 객체 간의 사용 규칙을 정의할 때 사용하는 문법이다.
- 즉 호출할 때 어떤 이름의 메서드를 어떤 파라미터로 호출해야 하는 지 정의한 것이다.
- 구체적인 동작은 클래스가 구현한다.
- 호출자와 피호출자 간의 직접적인 종속성을 제거할 수 있어 유지보수에 좋다. 

**인터페이스* 에 대한 **추상 클래스** 의 활용

- 인터페이스에 정의된 규칙이 많을 경우, 그 많은 메서드를 직접 구현하는 일은 번거롭다.
- 그래서 **추상 클래스** 를 통해 일부 메서드를 구현하고,
  나머지는 서브 클래스에게 맡기는 프로그래밍 기법을 많이 사용한다. 즉 추상클래스를 활용해서 인터페이스의 일부 구현을 처리한다(인터페이스의 구현을 보조). 인터페이스와 추상클래스의 콜라보(collaboration)인 것이다.  

## 등장 배경
객체에 일을 시키는 방식은 비슷한데 메서드 시그니처가 다르기 때문에 호출 시 `일관성`이 없다. 즉 worker 객체를 사용하는 입장에서는 각 worker에 어떤 메서드가 있는지 확인해서 그 형식에 맞춰야 하기 때문에 객체를 사용하기가 불편하다.  
유사한 일을 하는 데 객체 사용법이 다르면 쓰기가 매우 불편하다. 따라서 유사한 일을 하는 객체에 대해 사용법을 통일하자. 이를 위해서는
- 객체의 사용 규칙을 정의한다.
- 클래스를 정의할때 그 규칙에 따라 만든다.
- 규칙에 따라 만든 클래스를 사용할 때는 일관된 방법으로 메서드를 호출할 수 있다.

이렇게 `객체의 사용 규칙`을 정의하는 문법이 "인터페이스"이다.  

## 호출 규칙으로서의 인터페이스
인터페이스는 caller와 callee 사이의 호출 규칙을 정의하는 문법이다.
- 사용 규칙: Worker(인터페이스)
- caller(호출자; 사용자): Exam01
- callee(피호출차; 도구): BlueWorker(Worker를 구현), JubuWorker(Worker 구현), WhiteWorker(Worker 구현)

호출 규칙이란? 메서드 형식을 의미한다.  
메서드 몸체는 규칙에 따라 만드는 클래스에서 정의하는 것이다.  

## 추상 클래스와 인터페이스 
### 인터페이스 구현을 돕는 추상 클래스
추상 클래스를 이용하여 인터페이스 구현을 `도와줄 수 있다.` 인터페이스에 메서드가 많지만, 그 중 특정 메서드만 주로 구현한다면 개발자가 인터페이스를 구현하기 편하도록 서브 클래스에서 오버라이딩할 메서드를 제외한 나머지 메서드를 추상클래스에서 구현한다.  
```java
public abstract class AbstractServlet implements Servlet {
    public void init(){}
    public void destroy(){}
    public String getServlet() {
        return null;
    }
    public String getServletConfig() {
        return null;
    }
}
```
- 인터페이스를 구현한다는 것은 **인터페이스에 선언된 모든 메서드를 구현한다**는 뜻이다.
  - 인터페이스에 선언된 메서드를 **한 개라도 빠뜨리면** 추상 메서드를 갖고 있는 상태가 된다. 즉 일반 클래스가 될 수 없고, **추상 클래스**가 되어야 한다.
- 직접 인터페이스를 구현하기보다 추상 클래스를 상속받는다.
  - 인터페이스를 직접 구현하면 인터페이스에 선언된 모든 메서드를 구현해야 하지만, 미리 인터페이스의 몇몇 메서드를 구현한 추상 클래스를 상속받는다면 서브 클래스는 좀 더 쉽게 인터페이스를 구현할 수 있다(추상 클래스에서 구현하지 않은 메서드만 정의하면 된다)
- 즉 인터페이스 메서드가 많을 경우 일부 메서드를 미리 구현함으로써 개발자가 좀 더 쉽게 인터페이스를 구현할 수 있게 도와주는 용도로 "추상 클래스" 문법을 사용할 수 있다.

## 인터페이스와 추상클래스

인터페이스와 추상클래스는 엄연히 다르다.

- 추상 클래스 = 변수 + 구현된 메서드 + 추상 메서드
- 인터페이스 = 추상 메서드
  - 추가적으로 구현된 default 메서드, static 메서드와 final변수가 있다. 이는 다음 시간에 배울 것이다.

## 인터페이스 레퍼런스

- 인터페이스를 구현한 클래스의 객체 주소는 다 저장할 수 있다.
- 그 객체가 누구의 자식인 지는 상관하지 않는다.

## final
- 인터페이스에 선언되는 모든 변수는 public으로 공개되고, static으로 클래스 변수가 된다. 또한 규칙은 변경되어선느 안 되기 때문에 모든 변수는 `final`로 선언한다. final변수는 선언과 동시에 특정 값으로 초기화해야 한다.

# 인터페이스 사용법
```java
public interface A { void m1();}
public interface B extends A { void m2(); }
public interface C { void m3(); }
public interface D { void m2(); void m4; }
public interface D2 { int m3(); }
```

## 다중 인터페이스

- **클래스는 여러 개의 규칙을 이행할 수 있다.**

- 한 클래스가 여러 개의 인터페이스(사용 규칙)을 구현했다면, 

  **각 인터페이스로 구분해서 그 객체를 사용할 수 있다.**
  
  즉, 구현체를 어떤 인터페이스 레퍼런스에 담느냐에 따라 사용할 때 따르는 규칙이 달라진다.

```java
public class Exam02 implements B, C {
    @Override
    public void m2() {} // B의 인터페이스 구현
    @Override
    public void m1() {} // B의 수퍼 인터페이스 구현
    @Override
    public void x3() {} // C의 인터페이스 구현
    
    public static void main(String[] args) {
        // 클래스 타입 레퍼런스는 해당 클래스에 정의된 메서드를 호출할 수 있다.
        Exam02 obj = new Exam02();
        
        // B 인터페이스 레퍼런스에 담는다. 
        // 즉, Exam02 객체를 B 규칙에 따라 사용한다.
        B obj2 = obj;
        obj2.m1();
        obj2.m2();
		//obj2.m3(); => 컴파일 오류
        
        // C 인터페이스 레퍼런스에 담는다.
        // 즉, Exam02 객체를 C 규칙에 따라 사용한다.
        C obj3 = obj;
        //obj3.m1(); => 컴파일 오류
        //obj3.m2(); => 컴파일 오류
        obj3.m3();
    }
}
```
## 추상 클래스/인터페이스의 차이점

- 추상클래스와 인터페이스 모두 추상 메서드를 갖기 때문에 헷갈릴 수 있으나 둘의 사용 목적은 엄연히 다르다.
- 추상 클래스의 목적은 **필드와 메서드를 물려주는 것**이다. 이때 `겸사겸사`추상 메서드도 선언한다

- 만약 추상 클래스에 추상 메서드만 있다면, 상속해줄 필드와 메서드가 없기 때문에 추상클래스로 만들 이유가 없다. 이 경우 인터페이스로 만들어야 옳다.
- 인터페이스의 목적은 이 메서드를 구현해야 한다는 제약점을 만드는 것, 규칙을 정의하는 문법이다.  

> [람다](https://multifrontgarden.tistory.com/124)란? 스트림과 함께 함수형 프로그래밍을 받아들이기 위해 Java8부터 추가된 문법이다. 람다의 핵심은 지울 수 있는 것은 모두 지우자는 것이다. 모든 걸 컴파일러의 추론에 의지하고 코드로 표현하는 건 다 없애버려 코드를 간결하게 만드는 것이다. 람다 표현식으로 구현이 가능한 인터페이스는 오직 추상 메서드가 1개뿐인 인터페이스만 가능하며 그렇기 때문에 추상 메서드가 1개인 인터페이스를 "함수형 인터페이스"라고 부르게 되었다.  


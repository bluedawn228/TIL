# 흐름
- 기능확장을 하다 한계를 느낀다.
- 유지보수하다 한계를 느낀다.
    - 유지보수의 핵심 : 관리 용이, 재사용 용이, 교체 용이(부품화)

## 01. 자바 프로젝트 생성  
## 02. 리터럴과 표준 출력장치(콘솔)
> 자바는 System.out 객체를 통해 표준 출력장치를 다룬다.
## 03. 변수와 표준 입력장치(키보드)
> 자바는 Systme.in 객체를 통해 표준 입력장치를 다룬다.
## 04. 배열과 흐름 제어문 : 변수의 한계
> 기능을 확장하려다 변수만으로는 한계를 느껴 배열을 도입했다.  
> 배열은 같은 종류의 변수를 여러 개 만들 때 사용하는 문법이다.
## 05 ~ 09
계속 빼내고 묶고 빼내고 묶고 public으로 공개하고  
05 - 모든 변수+코드를 전부 메인 메서드가 가지고 있었다.  
06 - 코드를 기능 단위로 묶어 메서드로 만들어서 밖으로 빼냈다. (이 때 메인메서드에서 빼낸 메서드를 써야되니까 스태틱으로 만들었다. 변수들도 메서드들이 써야되니까 빼내서 스태틱으로 만들었다.)  
07 - 빼낸 변수들을 묶어서 스태틱 클래스를 만들었다. 이때 클래스 안에 들어간 변수들은 스태틱 변수가 아닌 인스턴스 변수로 했다.  
08 - 만든 스태틱 클래스와 연관있는 스태틱 메서드들을 묶어서 또 스태틱 클래스로 만들었다. 그리고 아예 나한테서 빼내서 새로운 클래스를 생성했다.  
09 - 빼낸 클래스들을 새 패키지로 묶었다.   
결론 : 스태틱 멤버는 아무거도 아니다 원래 다 메인메서드꺼였다. 그냥 내꺼라고 생각하면된다.    
## 05. 명령어의 도입과 main()
> 모든 변수+코드를 전부 메인 메서드가 가지고 있으니 유지보수의 한계를 느낀다 → 그래서 메서드 추출 → 관리 용이, 재사용 용이
- 명령어를 도입하여 App, App2, App3를 하나의 App으로 합칠 수 있었다.
## 06. 메서드의 존재 이유 (메서드 추출 : Extract Method)
> 스태틱 변수, 스태틱 메서드로 구성
> 코드를 기능 단위로 묶어서 밖으로 빼내어 스태틱 메서드들을 만들었다.
> 마찬가지로 변수들도 빼내어 스태틱 변수들로 만들었다.
- 메서드의 존재 이유
    - 관리 용이
    - 재사용 용이
## 07. 클래스의 존재 이유(1) (클래스 추출 : Extract Class) : 사용자 정의 데이터 타입
> 스태틱 클래스(인스턴스 필드만 있음), 스태틱 변수, 스태틱 메서드로 구성
- 클래스의 존재 이유(1) : 사용자 정의 데이터 타입
    - 클래스는 설계도다. 이거로 인스턴스를 만든다.
## 08. 클래스의 존재 이유(2) (클래스 추출 : Extract Class) : 메서드를 한 곳에 묶어 관리
> 08에서 한거는 스태틱 멤버를 다른 클래스에다가 옮긴거 밖에 없다.
> 스태틱 클래스(07의 스태틱 클래스와 스태틱 메서드를 묶음), 스태틱 변수, 스태틱 메서드
- 클래스의 존재 이유(2)
    - 관리 용이(메서드를 한 곳에 묶어 관리)
## 09. 패키지는 가족
- 같은 패키지면 임포트도 안해도 되고, private만 아니면 default 부터는 그냥 쓸 수 있다.
- default, public, private
- protected
## 10. 의존 : 아직까지 스태틱 멤버만 있기 때문에 스태틱 멤버만 캡슐화
클래스를 나누니까 당연히 클래스끼리 의존관계가 있다.
## 11. 스태틱 필드와 스태틱 메서드의 한계
> 기능을 확장하려다 유지보수의 한계를 느낀다
> 물론 스태틱 멤버만으로도 모든 프로그램을 짤 수 있다. 그러나 유지보수가 너무너무 힘들다. → 인스턴스 필드, 인스턴스 메서드 만듬
## 12. 인스턴스 필드와 인스턴스 메서드
## 13. 생성자  
> 의존객체가 필요한 상황에서 생성자를 사용하지 않으면 (위의 코드와 같이) 의존객체 주입하는 것을 잊을 수 있다. 주입이 되지 않아 인스턴스 주소 대신 null이 있어서 NullPoint Exception이 발생할 수 있는 것이다. 이는 런타임에러로  컴파일 단계에서는 필요한 의존객체를 주입하지 않았다는 것을 알 수 없기 때문에, 주입을 강제할 방법이 필요하다. → 생성자가 의존객체 주입을 강제하는 장치다
## 14. 캡슐화 : 하이 코히젼 : 인스턴스 멤버 캡슐화
## 15. 캡슐화 : 접근제어
## 16. 다형성(polymorphism) / 형변환 응용
## 17. 제네릭의 필요성과 사용법
> 다형적 변수의 한계를 제네릭을 도입하여 해결
## 18. CRUD : ArrayList
## 19. LinkedList
## 20. Stack
## 21. Queue
## 22. 상속 : 일반화(generalization)를 이용한 공통점 분리
- → 일반화하고 나니까 슈퍼클래스의 인스턴스를 생성못하게 강제하는 문법, 슈퍼클래스의 메서드를 개발자가 오버라이딩하게 강제하는 문법이 필요하다 → 추상 클래스, 추상 메서드 문법 만듬

## 23. 추상 클래스와 추상 메서드

## 24. 인터페이스를 활용한 객체 사용 규칙 정의

## 25. `Iterator` 디자인 패턴

## 26-a. 중첩 클래스 : 스태틱 중첩 클래스(static nested class)

## 26-b. 중첩 클래스 : 논스태틱 중첩 클래스(non-static nested class; inner class)

## 26-c. 중첩 클래스 : 로컬 클래스(local class)

## 26-d. 중첩 클래스 : 익명 클래스(anonymous class)

## 27. 자바 컬렉션 API 사용하기 - 앞에서 한 자료구조를 자바 API로

## 28-a. 'Command' 디자인 패턴을 적용하기 : 메서드를 객체로 분리하기

## 28-b. 'Command' 디자인 패턴을 적용하기 : Map 을 이용한 커맨드 객체 관리

## 29. 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법

## 30-a. 파일 입출력 API : 바이너리 형식으로 데이터를 읽고 쓰기(FileInputStream/FileOutputStream)

## 30-b. 파일 입출력 API : 데코레이터 객체 활용하기(DataInputStream/DataOutputStream)

## 30-c. 파일 입출력 API : 버퍼 사용하기(BufferedInputStream/BufferedOutputStream)

## 30-d. 파일 입출력 API : 객체 읽고 쓰기(ObjectInputStream/ObjectOutputStream)

## 30-e. 파일 입출력 API : 리팩터링 I

## 31-a. 파일 입출력 API : 텍스트 형식(CSV 파일 포맷)으로 데이터를 읽고 쓰기(FileReader/FileWriter)

## 31-b. 파일 입출력 API : 버퍼 사용하기(BufferedReader/BufferedWriter)

## 31-c. 파일 입출력 API : 리팩터링 I

## 31-d. 파일 입출력 API : 리팩터링 II

## 32. JSON 형식으로 객체를 읽고 쓰기 : Gson 라이브러리 활용

## 33-a. `Observer` 디자인 패턴 : 프로젝트에 적용하기

## 33-b. `Observer` 디자인 패턴 : `Observer` 객체를 통해 파일 다루기

## 34-a. 네트워크 API를 활용한 C/S 아키텍처 : 클라이언트/서버 프로젝트 준비

## 34-b. 네트워크 API를 활용한 C/S 아키텍처 : 간단한 메시지 송수신

## 34-c. 네트워크 API를 활용한 C/S 아키텍처 : 사용자가 입력한 명령처리

## 34-d. 네트워크 API를 활용한 C/S 아키텍처 : 응답 프로토콜 변경

## 34-e. 네트워크 API를 활용한 C/S 아키텍처 : 다중 클라이언트의 요청 처리

## 34-f. 네트워크 API를 활용한 C/S 아키텍처 :  다중 클라이언트의 동시 접속 처리

## 34-g. 네트워크 API를 활용한 C/S 아키텍처 : PMS 코드를 C/S로 분리

## 35. 동일한 자원으로 더 많은 클라이언트 요청을 처리하는 방법 : Stateful을 Stateless로 전환하기

## 36-a. 스레드풀을 이용하여 스레드를 재사용하기 : 스레드풀 구현하기

## 36-b. 스레드풀을 이용하여 스레드를 재사용하기 : 자바에서 제공하는 스레드풀 사용하기

## 37-a. 데이터 관리를 DBMS에게 맡기기 : JDBC API 사용하기

## 37-b. 데이터 관리를 DBMS에게 맡기기 : SQL 삽입 공격과 자바 시큐어 코딩

## 37-c. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 다루기

## 37-d. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 다루기 II

## 38-a. 데이터 처리 코드를 별도의 클래스로 분리하기 : DAO 클래스 도입

## 38-b. 데이터 처리 코드를 별도의 클래스로 분리하기 : DAO 인터페이스 도입

## 38-c. 데이터 처리 코드를 별도의 클래스로 분리하기 : 의존 객체 주입과 DB 커넥션 객체 공유하기

## 38-d. 데이터 처리 코드를 별도의 클래스로 분리하기 : 트랜잭션이 필요한 이유

## 39. 로그인/로그아웃 구현하기 : 사용자 인증(authentication)하기

## 40-a. 커맨드 실행 전/후에 기능 추가하기: 디자인 패턴 적용 전

## 40-b. 커맨드 실행 전/후에 기능 추가하기: Chain of Responsibility 패턴 적용

## 40-c. 커맨드 실행 전/후에 기능 추가하기: init() 와 destroy()의 필요성

## 41-a. DB 프로그래밍 더 쉽고 간단히 하는 방법 : Mybatis 퍼시스턴스 프레임워크 도입

## 41-b. DB 프로그래밍 더 쉽고 간단히 하는 방법 : Mybatis 기타 기능 활용하기

## 41-c. DB 프로그래밍 더 쉽고 간단히 하는 방법 : Mybatis에서 트랜잭션 다루기

## 42. 비즈니스 로직 분리하기 : 서비스 객체의 도입

## 43-a. 애플리케이션 서버 아키텍처로 전환하기 : 클라이언트 + 애플리케이션 서버 + DBMS

## 43-b. 애플리케이션 서버 아키텍처로 전환하기 : 세션 다루기

## 43-c. 애플리케이션 서버 아키텍처로 전환하기 : 커맨드 객체 생성 자동화

## 44-a. 웹 애플리케이션 서버(Web Application Server: WAS) 아키텍처로 전환하기 : Servlet 기술 도입

## 44-b. 웹 애플리케이션 서버(Web Application Server: WAS) 아키텍처로 전환하기 : forward/include, refresh/redirect 활용하기

## 45-a. MVC 아키텍처로 전환하기 : JSP를 활용하여 view 컴포넌트 분리하기

## 45-b. MVC 아키텍처로 전환하기 : EL 및 JSTL 활용하기

## 45-c. MVC 아키텍처로 전환하기 : 프론트 컨트롤러 도입하기

## 45-d. MVC 아키텍처로 전환하기 : 페이지 컨트롤러를 POJO로 전환하기

## 46-a. Spring WebMVC 프레임워크 도입하기 : DispatcherServlet 프론트 컨트롤러 적용

## 46-b. Spring WebMVC 프레임워크 도입하기 : 페이지 컨트롤러에서 요청 파라미터 다루기

## 46-c. Spring WebMVC 프레임워크 도입하기 : Mybatis와 Spring을 연동하기

## 46-d. ?  